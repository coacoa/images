@startuml
title Linux: 自動ログインと GNOME Keyring の仕組み

actor User
participant "Display Manager\n(GDM / SDDM / LightDM)" as DM
participant "Session Manager\n(GNOME / KDE / Xfce)" as SM
participant "GNOME Keyring\n(Seahorse / keyring-daemon)" as KR
participant "Remote Desktop\n(VNC / RDP / xrdp)" as RD
participant "App / Network Service\n(例: Chrome, NetworkManager)" as APP

== 起動・ログイン処理 ==
User -> DM : 電源投入 → ログイン画面表示
DM -> SM : 自動ログインを実行（ユーザーPW入力なし）
SM -> KR : セッション開始時にKeyringを開こうとする
KR -> User : 🔐 「Keyringのパスワードを入力してください」
note right
Keyringは暗号化された「秘密情報(SSH鍵/ネットPW)」を保存  
→ 自動ログインでは認証情報が提供されず解錠できない
end note

== リモートデスクトップ接続 ==
User -> RD : RDP/VNCなどで接続（ログイン済みセッションを利用）
RD -> SM : デスクトップセッションを転送表示
APP -> KR : 保存済みパスワード(例: Wi-Fi, Mail)を要求
KR -> User : 🔒 再びKeyringパスワードを要求

== オプション ==
note over KR
・ログインPWとKeyringPWを同一化すれば自動解錠可能  
　→ ただし「自動ログイン」ではOSがPWを渡さないため不可  
・対応策：  
　1️⃣ Keyringを無効化する  
　2️⃣ Keyring PWを空に設定する（セキュリティ低下注意）  
　3️⃣ PAM設定で自動解錠を有効にする（例: gnome-keyring-pam）
end note

@enduml


@startuml Linux_Caps_Ctrl_Tools
title Linux: Caps LockをCtrlとして追加するフローと主要ツール

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(設定ツール/ファイル)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer: X11 Server or Wayland Compositor

== 設定の適用 (X11 & Wayland共通) ==
User -> DEConfig: 1. 設定ツールで 'ctrl:nocaps' を適用
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note left of DEConfig
  **X11 時代の主なツール:**
  - setxkbmap (XKBオプション一時適用)
  - xmodmap (古い/非推奨。キーコードを直接操作)
  - xcape (キーの押し方を拡張: Tap/Hold)

  **Wayland 時代の強力な選択肢 (Kernelレベル):**
  - keyd (Wayland/X11/TTY全体対応のデーモン)
  - kanata, xremap (より高度な層/マクロ設定)
  - input-remapper (GUIツール)
end note

== X11 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
DisplayServer -> XKB: 5. XKB定義を参照 (内部処理)
XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)

note right of DisplayServer: X11の特徴: X Server内でXKBによる\n変換が一元的に行われる。

== Wayland 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\nイベントを内部的に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

note left of DisplayServer: Waylandの特徴: Compositorが変換を担う。\nXKB設定はCompositorへの「指示」として機能する。

@enduml

@startuml Linux_Caps_Ctrl_Final
title Linux: Caps LockをCtrlとして追加する詳細フロー (Option: ctrl:nocaps)

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer: X11 Server or Wayland Compositor

== 設定の適用 (X11 & Wayland共通) ==
User -> DEConfig: 1. システム設定で 'ctrl:nocaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB: XKBはキーボードマッピングの標準フレームワーク。\nDisplay Serverに適用される。

== X11 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
DisplayServer -> XKB: 5. XKB定義を参照 (内部処理)
XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)

note right of DisplayServer: X11の特徴: X Server内でXKBによる\n変換が一元的に行われる。

== Wayland 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\nイベントを内部的に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

note left of DisplayServer: Waylandの特徴: Compositorが変換を担う。\nXKB設定はCompositorへの「指示」として機能する。

@enduml
@startuml Linux_Caps_Ctrl_No_Group_Fixed
title Linux: Caps LockをCtrlとして追加する詳細フロー (Option: ctrl:nocaps)

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 (X11 & Wayland共通) ==
User -> DEConfig: 1. システム設定で 'ctrl:nocaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  XKBはキーボードマッピングの標準フレームワーク。\n
  Display Serverに適用される。
end note

== X11 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
DisplayServer -> XKB: 5. XKB定義を参照 (内部処理)
XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)

note right of DisplayServer
  X11の特徴: X Server内でXKBによる\n
  変換が一元的に行われる。
end note

== Wayland 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\nイベントを内部的に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

@enduml


@startuml Linux_Caps_Ctrl_No_Group_Fixed
title Linux: Caps Lock -> Ctrl リマップの詳細フロー (Groupなし・最終修正)

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 (X11 & Wayland共通) ==
User -> DEConfig: 1. システム設定で 'ctrl:swapcaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  XKBはキーボードマッピングの標準フレームワーク。\n
  Display Serverに適用される。
end note

== X11 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
DisplayServer -> XKB: 5. XKB定義を参照 (内部処理)
XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)

note right of DisplayServer
  X11の特徴: X Server内でXKBによる\n
  変換が一元的に行われる。
end note

== Wayland 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\nイベントを内部的に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

note right of DisplayServer
  Waylandの特徴: Compositorが変換を担う。\n
  XKB設定はCompositorへの「指示」として機能する。
end note

@enduml

@startuml Linux_Caps_Ctrl_No_Group
title Linux: Caps Lock -> Ctrl リマップの詳細フロー (Groupなし)

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 (X11 & Wayland共通) ==
User -> DEConfig: 1. システム設定で 'ctrl:swapcaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  XKBはキーボードマッピングの標準フレームワークで、\n
  Display Serverに適用される。
end note

== X11 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
DisplayServer -> XKB: 5. XKB定義を参照 (内部処理)
XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)

note right of DisplayServer
  **X11の特徴:** X Server内でXKBによる\n
  変換が一元的に行われる。
end note

== Wayland 環境での動作フロー ==
User -> Kernel: Caps Lockキーを押す (Scan Code)
Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\nイベントを内部的に変換
DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

note left of DisplayServer:
  **Waylandの特徴:** Compositorが変換を担う。\n
  XKB設定はCompositorへの「指示」として機能する。
end note

@enduml

@startuml Linux_Caps_Ctrl_Detail_Fixed
title Linux: Caps Lock -> Ctrl リマップの詳細フロー

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 ==
User -> DEConfig: 1. システム設定で 'ctrl:swapcaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  **XKB:**
  キーボードマッピングの標準フレームワーク。\n
  X11/Wayland (Compositor) の両方で利用される。
end note

== X11 環境での動作 ==
group X11 (キーマップ変換)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
    DisplayServer -> XKB: 5. XKB定義を参照
    XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)
end

note right of DisplayServer
  X11では、XKBによる変換が\n
  X Server内部で一元的に行われる。
end note

== Wayland 環境での動作 ==
group Wayland (Compositor処理)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
    DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\n  イベントを内部的に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

    note left of DisplayServer:
      GNOME/KDEなどのCompositorがキーマップ変換を担う。\n
      XKB設定はCompositorへの「指示」として機能する。
    end note
end

@enduml

@startuml Linux_Caps_Ctrl_Detail_Fixed
title Linux: Caps Lock -> Ctrl リマップの詳細フロー

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 ==
User -> DEConfig: 1. システム設定で 'ctrl:swapcaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  **XKB:**
  キーボードマッピングの標準フレームワーク。\n
  X11/Wayland (Compositor) の両方で利用される。
end note

== X11 環境での動作 ==
group X11 (キーマップ変換)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
    DisplayServer -> XKB: 5. XKB定義を参照
    XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)
end

note right of DisplayServer
  X11では、XKBによる変換が\n
  X Server内部で一元的に行われる。
end note

== Wayland 環境での動作 ==
group Wayland (Compositor処理)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
    DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\n  イベントを内部的に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

    note left of DisplayServer: 
      GNOME/KDEなどのCompositorがキーマップ変換を担う。\n
      XKB設定はCompositorへの「指示」として機能する。
    end note
end

@enduml

@startuml Linux_Caps_Ctrl_Detail
title Linux: Caps Lock -> Ctrl リマップの詳細フロー

actor User
participant Kernel as "① Kernel (Input Layer)"
participant DEConfig as "② 設定機構\n(gsettings/xorg.conf/CLI)"
participant XKB as "③ XKB (X Keyboard Extension)"
participant DisplayServer as "④ Display Server"
participant App as "⑤ アプリケーション"

note over DisplayServer
  X11 Server or Wayland Compositor
end note

== 設定の適用 ==
User -> DEConfig: 1. システム設定で 'ctrl:swapcaps' を選択
DEConfig -> XKB: 2. XKBルール/オプションをロード
XKB -> DisplayServer: 3. XKBキーマップを適用

note right of XKB
  **XKB:**
  キーボードマッピングの標準フレームワーク。\n
  X11/Wayland (Compositor) の両方で利用される。
end note

== X11 環境での動作 ==
group X11 (キーマップ変換)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しX Serverへ送信
    DisplayServer -> XKB: 5. XKB定義を参照
    XKB -> DisplayServer: Keycode 66 (Caps) を Keycode 37 (Ctrl) の意味に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (KeyDown/KeyUp)
end

note right of DisplayServer
  X11では、XKBによる変換が\n
  X Server内部で一元的に行われる。
end note

== Wayland 環境での動作 ==
group Wayland (Compositor処理)
    User -> Kernel: Caps Lockキーを押す (Scan Code)
    Kernel -> DisplayServer: 4. Keycodeに変換しCompositorへ送信
    DisplayServer -> DisplayServer: 5. Compositorが設定 (XKB) を参照し、\n  イベントを内部的に変換
    DisplayServer -> App: 6. Ctrlイベントとして送信 (Input Event)

    note left of DisplayServer: 
      * GNOME/KDEなどのCompositorが\n  キーマップ変換を担う。
      * XKB設定はCompositorへの\n  「指示」として機能する。
    end note
end

@enduml

@startuml Caps_Ctrl_X11_Wayland
title Caps Lock -> Ctrl リマップ (X11/Wayland対応版)

actor User
participant OS as "OS (Kernel/System)"
participant Settings as "設定機構\n(gsettings/xorg.conf)"
participant Server as "Display Server"
participant App as "アプリケーション"

note over Server
  X11 or Wayland Compositor
end note

== Windows (参考: PowerToys利用の概念) ==
group Windows Flow
    User -> Settings: 1. PowerToysで Caps Lock -> Ctrl を設定
    Settings -> Server: 2. イベントフックを有効化
    User -> OS: Caps Lockキーを押す
    OS -> Server: 3. Keycode受信
    Server -> Settings: 4. フックしたイベントを変換
    Settings -> Server: 5. Ctrlイベントとして再送信
    Server -> App: 6. Ctrlとして処理される
end

== Linux: X11 環境 ==
group X11 Flow (標準的)
    User -> Settings: 1. setxkbmap / xorg.conf で設定
    Settings -> Server: 2. XKB設定 (ctrl:swapcaps) をロード
    User -> OS: Caps Lockキーを押す
    OS -> Server: 3. Keycode受信
    Server -> Server: 4. XKBで定義されたキーマップを参照し変換
    Server -> App: 5. Ctrlとして処理される
end

== Linux: Wayland 環境 ==
group Wayland Flow (Compositor依存)
    User -> Settings: 1. gsettings / 環境設定ファイルで設定
    Settings -> Server: 2. XKB設定 (ctrl:swapcaps) をCompositorに通知
    User -> OS: Caps Lockキーを押す
    OS -> Server: 3. Keycode受信
    Server -> Server: 4. Compositor内でキーイベントを処理・変換
    Server -> App: 5. Ctrlとして処理される
end

note right of Settings
  Waylandの場合:
  GNOME/KDEの設定が優先され、
  Compositor (Server) がその設定に基づいて処理を行う。
end note

@enduml


@startuml Simplest_Caps_Ctrl_Remap
title Caps Lock -> Ctrl リマップ (最簡略版)

actor User
participant OS as "OS (Win/Linux)"
participant Remapper as "キーリマップ機能"
participant App as "アプリケーション"

== Windows (PowerToys利用の概念) ==

User -> Remapper : 1. PowerToysをインストール・設定
Remapper -> OS : 2. キーボードイベントをフック
User -> OS : Caps Lockキーを押す
OS -> Remapper : 3. Caps Lockイベントを受信
Remapper -> OS : 4. Ctrlイベントに変換して送信
OS -> App : 5. Ctrlとして処理される

== Linux (XKB利用の概念) ==

User -> OS : 1. setxkbmap / gsettings で設定
OS -> Remapper : 2. XKBオプション (ctrl:swapcaps) を適用
User -> OS : Caps Lockキーを押す
OS -> Remapper : 3. Caps Lockイベントを受信
Remapper -> OS : 4. Ctrlイベントとして処理
OS -> App : 5. Ctrlとして処理される

note over Remapper, App: **Remapperは、WindowsではPowerToys、LinuxではXKB設定を指す**

@enduml

@startuml Linux_Package_Management_Layers
title Linux パッケージ管理の進化と層構造（①〜⑤）

actor User
participant Kernel as "① Kernel 層\n(Linux Kernel)"
participant Traditional as "② 従来パッケージ管理\n(apt / dnf / pacman)"
participant Universal as "③ 新世代パッケージ\n(Snap / Flatpak / AppImage)"
participant Nix as "④ 宣言的パッケージ管理\n(Nix / Nixpkgs / Flakes)"
participant App as "⑤ アプリ層\n(CLI / GUI アプリ)"

== 基本的なパッケージ導入の流れ ==

group 従来パッケージ管理 (②)
    User -> Traditional : apt install firefox など
    Traditional -> Kernel : 依存関係解決とシステムに導入
    Kernel -> App : アプリを利用可能
end

group 新世代パッケージ (③)
    User -> Universal : snap install code / flatpak install firefox
    Universal -> Kernel : サンドボックス/コンテナ技術を利用
    Universal -> App : 隔離された環境で実行
end

group 宣言的パッケージ管理 (④)
    User -> Nix : nix profile install firefox / nixos-rebuild
    Nix -> Kernel : 独立したハッシュ付きストアに格納 (Nix Store)
    Nix -> App : 再現可能な環境で実行
end

== 各層の説明 (シーケンスとは独立) ==

note over Kernel: ① **カーネル層**\nハードウェアを直接制御する中心部。\n全てのアプリはここを経由して動作する。
note over Traditional: ② **従来パッケージ管理 (apt / dnf)**\nOSに統合された標準方式。軽量だが、\n他のディストロとの互換性が低い。
note over Universal: ③ **新世代パッケージ (Snap / Flatpak)**\nアプリ単位で独立。サンドボックス化され安全。\nディストロ間共通で配布できるがサイズは大きめ。
note over Nix: ④ **宣言的パッケージ管理 (Nix)**\n設定ファイルに基づき環境を完全再現。\n依存関係をハッシュで管理し、衝突がない。
note over App: ⑤ **アプリ層**\n実際にユーザーが利用するソフトウェア。\nCLI（vim, git）や GUI（Firefox, VSCode）など。

@enduml

@startuml
title Linux パッケージ管理の進化と層構造（①〜⑤）

actor User
participant Kernel as "① Kernel 層\n(Linux Kernel)"
participant Traditional as "② 従来パッケージ管理\n(apt / dnf / pacman)"
participant Universal as "③ 新世代パッケージ\n(Snap / Flatpak / AppImage)"
participant Nix as "④ 宣言的パッケージ管理\n(Nix / Nixpkgs / Flakes)"
participant App as "⑤ アプリ層\n(CLI / GUI アプリ)"

== 基本的な流れ ==
User -> Traditional : apt install firefox など
Traditional -> Kernel : パッケージをシステムに導入
Kernel -> App : CLI/GUIアプリを利用可能

User -> Universal : snap install code / flatpak install firefox
Universal -> App : サンドボックスで実行
Universal -> Kernel : コンテナ的に隔離された環境で動作

User -> Nix : nix profile install firefox
Nix -> Kernel : ハッシュ付きストアに格納
Nix -> App : 再現可能な環境で実行

== 各層の説明 ==
note over Kernel
① **カーネル層**
ハードウェアを直接制御する中心部。
全てのアプリやパッケージはここを経由して動作する。
end note

note over Traditional
② **従来パッケージ管理 (apt / dnf / pacman)**
OSに統合された標準方式。軽量で高速だが、
他のディストロとの互換性が低い。
end note

note over Universal
③ **新世代パッケージ (Snap / Flatpak / AppImage)**
アプリ単位で独立。サンドボックス化され安全。
ディストロ間共通で配布できるがサイズは大きめ。
end note

note over Nix
④ **宣言的パッケージ管理 (Nix)**
設定ファイルに基づき環境を完全再現。
依存関係をハッシュで管理し、衝突がない。
開発・再現性重視の用途に最適。
end note

note over App
⑤ **アプリ層**
実際にユーザーが利用するソフトウェア。
CLI（vim, git）や GUI（Firefox, VSCode）など。
end note

@enduml


@startuml
title Linux パッケージ管理方式の比較（APT / DNF / Snap / Flatpak / AppImage / Nix）

actor User
participant Kernel as "Linux Kernel"
participant PackageManager as "従来のパッケージ管理\n(apt / dnf / pacman)"
participant UniversalPkg as "新世代パッケージ\n(Snap / Flatpak / AppImage)"
participant NixPkg as "宣言的パッケージ管理\n(Nix / Nixpkgs / Flakes)"
participant AppLayer as "アプリ層\n(GUI・CLIアプリ)"

== インストールの流れ ==
User -> PackageManager : apt install firefox
PackageManager -> Kernel : システム依存で構成
Kernel -> AppLayer : アプリをOSの一部として利用

User -> UniversalPkg : flatpak install firefox\nsnap install code
UniversalPkg -> Kernel : サンドボックス内で動作
UniversalPkg -> AppLayer : 独立したアプリ環境を提供

User -> NixPkg : nix-env -iA nixpkgs.firefox\nまたは flake.nix を適用
NixPkg -> Kernel : 再現可能な環境を構築 (/nix/store)
NixPkg -> AppLayer : 宣言ファイルに基づく構成・実行環境を提供

== 各方式の特徴 ==
note over PackageManager
📦 **従来方式 (apt, dnf, pacman)**  
- OS統合型  
- 軽量で安定  
- root権限が必要  
- 依存関係が壊れることもある  
- ディストロ固有
end note

note over UniversalPkg
📦 **新方式 (Snap / Flatpak / AppImage)**  
- 依存関係を封入（コンテナ的）  
- 各ディストロ共通で配布可能  
- Snap: Canonical主導、自動更新  
- Flatpak: Wayland向け、GUI中心  
- AppImage: インストール不要・ポータブル
end note

note over NixPkg
📦 **Nix パッケージ管理**  
- 宣言的・再現可能な環境構築  
- すべての依存関係をハッシュ管理  
- `/nix/store` に分離され他環境と衝突しない  
- システムにもユーザーにも適用可  
- Home Manager, Flakes などと連携可能
end note

note over AppLayer
🧩 **アプリ層**  
- CLIアプリ（vim, htop）  
- GUIアプリ（ブラウザ, IDE）  
- パッケージ形式により動作環境が異なる
end note

@enduml


@startuml
title Linux パッケージ管理方式の位置づけ（Debian, Ubuntu, Fedora など）

actor User
participant Kernel as "Linux Kernel"
participant PackageManager as "従来のパッケージ管理\n(apt / dnf / pacman)"
participant UniversalPkg as "新世代パッケージ\n(Snap / Flatpak / AppImage)"
participant AppLayer as "アプリ層\n(GUI・CLIアプリ)"

== インストールの流れ ==
User -> PackageManager : apt install firefox\n(システムの一部として導入)
PackageManager -> Kernel : パッケージ依存関係を解決しインストール
Kernel -> AppLayer : システム内でアプリを利用可能に

User -> UniversalPkg : snap install code\n(flatpak install firefox)
UniversalPkg -> AppLayer : サンドボックス内で動作
UniversalPkg -> Kernel : コンテナ的に分離された実行環境

== 各方式の特徴 ==
note over PackageManager
📦 **従来方式 (apt, dnf, pacman)**  
- OSに統合されたパッケージ管理  
- 軽量・安定  
- root権限が必要  
- システム依存が強い
end note

note over UniversalPkg
📦 **新方式 (Snap / Flatpak / AppImage)**  
- 依存関係を含めて1パッケージに封入  
- 各ディストリ間で共通利用が可能  
- アップデートが自動（Snap）  
- サイズが大きい、起動が遅い傾向あり
end note

note over AppLayer
🧩 アプリ層  
- CLIアプリ（vim, htop）  
- GUIアプリ（ブラウザ, IDE, Office など）  
- 配布形式は複数方式で提供される
end note

@enduml


@startuml
title 🌈 Linuxディストリビューション系統図（色分け版）

actor User #white

participant Kernel as "Linux Kernel\n(共通エンジン)" #lightgray

participant Debian as "Debian系\n(.deb / apt)" #lightblue
participant Ubuntu as "Ubuntu系\n(使いやすさ重視)" #skyblue

participant Fedora as "Fedora系\n(.rpm / dnf)" #lightcoral

participant Arch as "Arch系\n(pacman)" #palegreen

participant Nix as "Nix系\n(nix package system)" #lightgoldenrodyellow

== 基盤 ==
User -> Kernel : 「Linuxを使いたい」

note over Kernel
全ディストリ共有の心臓部
ハードウェアとの通信を担当
end note

== 派生 ==
Kernel -> Debian : 安定重視で派生
Debian -> Ubuntu : デスクトップ向け改善
Ubuntu -> User : 初心者にも扱いやすいUI

Kernel -> Fedora : Red Hat系の実験場
Fedora -> User : 企業向け最新機能を提供

Kernel -> Arch : ミニマル・自己構築志向
Arch -> User : 手動構築で柔軟性を実現

Kernel -> Nix : 宣言的・再現可能な環境管理
Nix -> User : 環境をコードで再現

== 系統比較 ==
note over Debian, Ubuntu
🩵 安定性重視  
apt / .deb ベース  
サーバー・デスクトップ両対応
end note

note over Fedora
❤️ 最新技術テストベッド  
Red Hat Enterprise Linux と近い構成
end note

note over Arch
💚 ミニマル・ローリングリリース  
必要なものだけ自分で構築
end note

note over Nix
💛 宣言的構成管理  
環境をまるごと再現可能
end note
@enduml


@startuml
title Linuxカーネルから派生する主要ディストリビューション系統

actor User
participant Kernel as "Linux Kernel\n(共通のエンジン)"
participant Debian as "Debian系\n(.deb / apt)"
participant Ubuntu as "Ubuntu系\n(使いやすさ重視)"
participant Fedora as "Fedora系\n(.rpm / dnf)"
participant Arch as "Arch系\n(pacman)"
participant Nix as "Nix系\n(nix package system)"

== 基盤 ==
User -> Kernel : 「Linuxを使いたい」

note over Kernel
全てのディストリビューションが共有する心臓部
ハードウェアとのやり取りを担当
end note

== 派生 ==
Kernel -> Debian : 安定性・保守性重視で派生
Debian -> Ubuntu : デスクトップ向けに改良
Ubuntu -> User : わかりやすいUI・初心者向け体験を提供

Kernel -> Fedora : 最新技術検証のための開発系統
Fedora -> User : RHELと互換性の高い環境を提供

Kernel -> Arch : ミニマルでカスタム自在な構成を提供
Arch -> User : 手動で全て構築する柔軟性を提供

Kernel -> Nix : 宣言的・再現可能な構成管理を実現
Nix -> User : 環境をコードで定義し再現可能

== 比較 ==
note over Debian, Ubuntu
「.deb」「apt」ベースの伝統的システム
安定・信頼性が高い
end note

note over Fedora
Red Hat 系の源流
企業向けの最新機能テストベッド
end note

note over Arch
軽量・ローリングリリース
「自分で作るLinux」
end note

note over Nix
構成を宣言的に管理
複数環境の再現が容易
end note
@enduml


@startuml
title Linuxカーネルから派生する主要ディストリビューション系統

actor User
participant Kernel as "Linux Kernel\n(共通のエンジン)"
participant Debian as "Debian系\n(.deb / apt)"
participant Ubuntu as "Ubuntu系\n(使いやすさ重視)"
participant Fedora as "Fedora系\n(.rpm / dnf)"
participant Arch as "Arch系\n(pacman)"
participant Nix as "Nix系\n(nix package system)"

== 基盤 ==
User -> Kernel : 「Linuxを使いたい」

note over Kernel
全てのディストリビューションが共有する心臓部
ハードウェアとのやり取りを担当
end note

== 派生 ==
Kernel -> Debian : 安定性・保守性重視で派生
Debian -> Ubuntu : デスクトップ向けに改良
Ubuntu -> (User) : わかりやすいUI・初心者向け体験を提供

Kernel -> Fedora : 最新技術検証のための開発系統
Fedora -> (User) : RHELと互換性の高い環境を提供

Kernel -> Arch : ミニマルでカスタム自在な構成を提供
Arch -> (User) : 手動で全て構築する柔軟性を提供

Kernel -> Nix : 宣言的・再現可能な構成管理を実現
Nix -> (User) : 環境をコードで定義し再現可能

== 比較 ==
note over Debian, Ubuntu
「.deb」「apt」ベースの伝統的システム
安定・信頼性が高い
end note

note over Fedora
Red Hat 系の源流
企業向けの最新機能テストベッド
end note

note over Arch
軽量・ローリングリリース
「自分で作るLinux」
end note

note over Nix
構成を宣言的に管理
複数環境の再現が容易
end note
@enduml



@startuml
title ブートモード別のOS起動シーケンス比較（番号付き）

== Legacy BIOS モード ==
actor "ユーザー" as U
participant "① BIOS (Legacy)" as B
participant "② MBR（マスターブートレコード）" as M
participant "③ ブートローダ\n（GRUB / Windows Boot Mgr）" as L
participant "④ OS本体\n（Linux / Windows）" as O

U -> B : ① 電源を入れる
B -> M : ② ディスク先頭512バイト(MBR)を読み込む
M -> L : ③ ブートローダを実行
L -> O : ④ OSカーネルをロード
O --> U : ⑤ OS起動完了

note right of L
🟢 Linux → OK (GRUBがMBR対応)  
🟡 Windows 10以前 → OK  
🔴 Windows 11 → 非対応 (MBR不可)
end note

== UEFI モード ==
actor "ユーザー" as U2
participant "① UEFIファームウェア" as F
participant "② EFI System Partition (ESP)" as E
participant "③ EFIブートローダ\n（GRUB / systemd-boot / Windows Boot Mgr）" as L2
participant "④ OS本体\n（Linux / Windows）" as O2

U2 -> F : ① 電源を入れる
F -> E : ② EFIパーティションをスキャン（.efiファイル探索）
E -> L2 : ③ 選択されたEFIブートローダを実行
L2 -> O2 : ④ OSカーネルをロード
O2 --> U2 : ⑤ OS起動完了

note right of L2
🟢 Linux → ✅ UEFI対応済み  
🟢 Windows 10/11 → ✅ 必須（特に11）  
🔒 Secure Boot → 有効時は署名必須
end note

== まとめ ==
note over B,F
📘 まとめ  
・Linux → Legacy / UEFI どちらも起動可  
・Windows 11 → UEFI + GPT 必須  
・デュアルブート時 → 両方UEFIで統一が安全  
・Legacyモード混在はトラブルの原因になりやすい
end note
@enduml


@startuml
title ブートモード別のOS起動シーケンス比較

== Legacy BIOS モード ==
actor "ユーザー" as U
participant "BIOS (Legacy)" as B
participant "MBR" as M
participant "ブートローダ (GRUB / Windows Boot Mgr)" as L
participant "OS (Linux / Windows)" as O

U -> B : 電源投入
B -> M : ディスクの先頭512バイト(MBR)を読み込む
M -> L : ブートローダを実行
L -> O : OSカーネルをロード
O --> U : OS起動完了

note right of L
Linux → OK (GRUB対応)
Windows 10以前 → OK
Windows 11 → ❌ 非対応 (MBR不可)
end note

== UEFI モード ==
actor "ユーザー" as U2
participant "UEFIファームウェア" as F
participant "EFI System Partition (ESP)" as E
participant "EFIブートローダ\n(GRUB / systemd-boot / Windows Boot Manager)" as L2
participant "OS (Linux / Windows)" as O2

U2 -> F : 電源投入
F -> E : EFIパーティションをスキャン (.efi)
E -> L2 : 選択されたEFIブートローダを実行
L2 -> O2 : OSカーネルをロード
O2 --> U2 : OS起動完了

note right of L2
Linux → ✅ UEFI対応
Windows 10/11 → ✅ 必須 (特に11)
Secure Boot → 要署名
end note

== まとめ ==
note over B,F
・Linux は Legacy / UEFI どちらも可  
・Windows 11 は UEFI + GPT 必須  
・デュアルブート時は同一モードで統一するのが安全
end note
@enduml


@startuml
title Linux: カーネルからアプリまで（Wayland / X11 を含む・主要選択肢付き）

actor User
participant Kernel as "Linux Kernel"
participant Shell as "Shell / Terminal"
participant ShellApp as "CLI アプリ (vim, emacs, htop)"
participant DisplayServer as "ディスプレイサーバ層\n(Wayland / X11)"
participant DMDE as "Display Manager / Desktop Environment / WM"
participant GUIApp as "GUI アプリ (ブラウザ, エディタ, IDE)"

== 流れ ==
User -> Kernel : システムコールを発行
Kernel -> Shell : CLI操作を提供
Shell -> ShellApp : CLIアプリを実行
Kernel -> DisplayServer : 画面描画を制御
DisplayServer -> DMDE : GUI表示とデスクトップ環境を提供
DMDE -> GUIApp : GUIアプリを表示・操作

== 各層の役割と主な選択肢 ==

note over Kernel
🧩 **カーネル層**
- Linux Kernel（全ディストロ共通）
- 各ディストロが異なるパッチ・設定を適用
例: Ubuntu kernel, Fedora kernel, NixOS kernel
end note

note over Shell
💻 **Shell 層**
- CLI操作のインターフェイス  
主な選択肢：
  - bash（標準的）
  - zsh（機能拡張が豊富）
  - fish（直感的補完）
  - dash（軽量・スクリプト用）
  - nushell（モダン・構造化出力）
end note

note over DisplayServer
🖥️ **ディスプレイサーバ層**
- GUI描画の基盤  
主な選択肢：
  - **X11 (X.Org)**: 古参・互換性広い・リモート描画可  
  - **Wayland**: 軽量・セキュア・低遅延  
Wayland上の代表的コンポジタ：
  - Mutter (GNOME)
  - KWin (KDE Plasma)
  - Weston (リファレンス)
  - Hyprland (モダン・アニメーション)
  - Sway (i3互換・Wayland)
end note

note over DMDE
🪟 **DM / DE / WM 層**
GUI環境の操作感や外観を定義  

**Display Manager (ログイン画面)**
  - GDM (GNOME)
  - SDDM (KDE)
  - LightDM (軽量)
  - LXDM, Ly など  

**Desktop Environment (デスクトップ環境)**
  - GNOME（統合型・Wayland推し）
  - KDE Plasma（高機能・カスタマイズ性）
  - XFCE（軽量安定）
  - LXQt（超軽量）
  - Cinnamon（Linux Mint系）
  - MATE（クラシックUI）
  - Budgie, Pantheon, Deepin など  

**Window Manager (WM単体派)**
  - i3 / Sway（タイル型）
  - dwm / xmonad / awesome（ハッカー向け）
  - Openbox / Fluxbox / IceWM（軽量フローティング）
  - Hyprland（Wayland対応タイル＋アニメ）
end note

note over GUIApp
🧠 **GUI アプリ層**
- 実際に使うアプリ  
代表例：
  - ブラウザ（Firefox, Chromium, Brave）
  - エディタ（VSCode, Gedit, Kate）
  - 画像編集（GIMP, Krita）
  - ファイルマネージャ（Nautilus, Dolphin, Thunar）
end note

@enduml


@startuml
title Linux: カーネルからアプリまで（Wayland / X11 を含む）

actor User
participant Kernel as "Linux Kernel"
participant Shell as "Shell / Terminal"
participant ShellApp as "CLI アプリ (vim, emacs, htop)"
participant DisplayServer as "ディスプレイサーバ層\n(Wayland / X11)"
participant DMDE as "Display Manager / Desktop Environment"
participant GUIApp as "GUI アプリ (ブラウザ, エディタ, IDE)"

== 流れ ==
User -> Kernel : システムコールを発行
Kernel -> Shell : CLI操作を提供
Shell -> ShellApp : CLIアプリを実行
Kernel -> DisplayServer : 画面描画を制御
DisplayServer -> DMDE : GUI表示とデスクトップ環境を提供
DMDE -> GUIApp : GUIアプリを表示・操作

note over Kernel
カーネルはハードウェアとユーザー空間の仲介者
end note

note over DisplayServer
Wayland / X11 は GUI の描画を管理する層  
- **X11**: 伝統的、リモート描画も可能  
- **Wayland**: 新世代、軽量でセキュア
end note

note over DMDE
Display Manager と Desktop Environment は  
GUI の見た目・操作感を提供  
(例: GDM+GNOME, SDDM+KDE)
end note

note over GUIApp
ユーザーが利用するアプリケーション層  
(ブラウザ, エディタ, IDE など)
end note

@enduml


@startuml
title 小選挙区＋比例代表（復活当選：賛否両論付き）

actor 有権者 as Voter
participant "候補A（重複立候補）" as Candidate
participant "選挙管理委員会" as Election
participant "政党（比例名簿）" as Party

== 投票 ==
Voter -> Candidate : 小選挙区票
Voter -> Party : 比例票

== 小選挙区結果 ==
Election -> Candidate : 落選
note right
  【批判】
  ●ここで落ちた＝有権者のNoでは？
  ●なのにまだ続くの？
end note

== 比例代表 ==
Election -> Party : 政党の得票に応じて議席配分
Party -> Candidate : 名簿上位のため「復活当選」

note over Candidate
  【賛成意見】
  ●小選挙区だけだと死票が多すぎる
  ●政党支持票を反映するのは公平
  ●専門家や経験者を国会に残す必要もある

  【批判意見】
  ●負けた人が議員になるのは不自然
  ●民意を逆転させてない？
  ●結局「政党の都合優先」では？
end note

@enduml


@startuml
title 小選挙区＋比例代表（復活当選のシンプル図）

actor 有権者 as Voter
participant "候補A（重複立候補）" as Candidate
participant "選挙管理委員会" as Election
participant "政党（比例名簿）" as Party

== 投票 ==
Voter -> Candidate : 小選挙区票
Voter -> Party : 比例票

== 小選挙区結果 ==
Election -> Candidate : 落選
note right
  ●普通ならここで終了のはず
end note

== 比例代表 ==
Election -> Party : 政党の得票に応じて議席配分
Party -> Candidate : 名簿上位のため「復活当選」

note over Candidate
  【批判メモ】
  ●有権者がNoと言ったのに復活？
  ●なぜ負けた人が議員になれる？
  ●これって民意の逆転では？
end note

@enduml


@startuml
title 小選挙区 ＋ 比例代表（重複立候補 → 復活当選）の流れ（批判メモ付き）

actor 有権者 as Voter
participant "小選挙区候補A\n(地域候補)" as LocalCandidateA
participant "小選挙区候補B\n(地域候補)" as LocalCandidateB
participant "政党（比例名簿）" as PartyList
participant "開票所 / 選管" as ElectionCommission
participant "議席配分" as SeatAllocation
participant "当選者発表" as WinnerAnnouncement

== 投票 ==
Voter -> LocalCandidateA : 小選挙区票（個人に投票）
Voter -> PartyList : 比例票（政党に投票）
note over Voter
  ●「人」ではなく「政党」にも1票必要？
  ●結局どっちを信じろって話？
end note

== 開票（小選挙区） ==
ElectionCommission -> ElectionCommission : 小選挙区票を集計
ElectionCommission -> WinnerAnnouncement : 小選挙区の当選者決定
WinnerAnnouncement -> LocalCandidateA : 小選挙区で当選（例）
note over LocalCandidateB
  ●ここで落選したら普通は終わりでは？
  ●「落ちたのにまだチャンスある」って何？
end note

== 開票（比例） ==
ElectionCommission -> ElectionCommission : 比例票を集計（政党別）
ElectionCommission -> SeatAllocation : 各政党に議席数を割当て

== 比例名簿で議席割当 ==
SeatAllocation -> PartyList : 割当議席数に基づく名簿上位から当選者決定

alt 候補者が重複立候補していた場合
    note right of PartyList
      ① 小選挙区で当選 → 比例枠は次点へ繰り下がる
      ② 小選挙区で落選だが名簿上位 → 比例で復活当選

      【批判メモ】
      ●「ゾンビ当選」って呼ばれる理由ここ！
      ●国民に「No」と言われた人がなぜ議員に？
      ●これって民意の否定では？
    end note
    PartyList -> WinnerAnnouncement : 比例で当選者（名簿上位）を通知
else 比例-only候補の場合
    PartyList -> WinnerAnnouncement : 名簿上位者が当選
    note right
      ●そもそも選挙区で顔見せすらしてない人が議員に？
      ●政党に忠誠心ある方が得なのでは？
    end note
end

== 最終発表 ==
WinnerAnnouncement -> LocalCandidateA : 小選挙区当選（既に当選）
WinnerAnnouncement -> LocalCandidateB : 比例で当選（復活当選の例）

note over WinnerAnnouncement
  【総評】
  ●「選挙で負けても議員になれる可能性がある制度」
  ●これで本当に“選挙の緊張感”あるの？
  ●なぜ日本はこんな仕組みを維持してる？
end note

@enduml



@startuml
title 小選挙区 ＋ 比例代表（重複立候補 → 復活当選）の流れ

actor 有権者 as Voter
participant "小選挙区候補A\n(地域候補)" as LocalCandidateA
participant "小選挙区候補B\n(地域候補)" as LocalCandidateB
participant "政党（比例名簿）" as PartyList
participant "開票所 / 選管" as ElectionCommission
participant "議席配分" as SeatAllocation
participant "当選者発表" as WinnerAnnouncement

== 投票 ==
Voter -> LocalCandidateA : 小選挙区票（個人に投票）
Voter -> PartyList : 比例票（政党に投票）

== 開票（小選挙区） ==
ElectionCommission -> ElectionCommission : 小選挙区票を集計
ElectionCommission -> WinnerAnnouncement : 小選挙区の当選者決定
WinnerAnnouncement -> LocalCandidateA : 小選挙区で当選（例）

== 開票（比例） ==
ElectionCommission -> ElectionCommission : 比例票を集計（政党別）
ElectionCommission -> SeatAllocation : 各政党に議席数を割当て

== 比例名簿で議席割当 ==
SeatAllocation -> PartyList : 割当議席数に基づく名簿上位から当選者決定

alt 候補者が重複立候補していた場合
    note right of PartyList
      ① 小選挙区で当選 → 比例枠は次点へ繰り下がる
      ② 小選挙区で落選だが名簿上位 → 比例で復活当選（ゾンビ当選）
    end note
    PartyList -> WinnerAnnouncement : 比例で当選者（名簿上位）を通知
else 比例-only候補の場合
    PartyList -> WinnerAnnouncement : 名簿上位者が当選
end

== 最終発表 ==
WinnerAnnouncement -> LocalCandidateA : 小選挙区当選（既に当選）
WinnerAnnouncement -> LocalCandidateB : 比例で当選（復活当選の例）
@enduml


@startuml
title Linux ディストリビューション比較: Ubuntu, Fedora, Debian, NixOS

actor User
participant Kernel as "Linux Kernel"
participant Shell as "Shell / Terminal"
participant ShellApp as "CLI アプリ (vim, emacs, htop)"
participant DMDE as "Display Manager / Desktop Environment"
participant GUIApp as "GUI アプリ (ブラウザ, エディタ, IDE)"

== 共通: カーネルと上位層 ==
User -> Kernel : システムコールを発行
Kernel -> Shell : CLI操作を提供
Shell -> ShellApp : CLIアプリを実行
Kernel -> DMDE : GUI表示とデスクトップ環境提供
DMDE -> GUIApp : GUIアプリを表示・操作

== Ubuntu の特徴 ==
note over Kernel, GUIApp
- 初心者向け、安定重視
- パッケージ管理: apt/dpkg
- デフォルト DE: GNOME
- 標準アプリ充実、コミュニティが活発
end note

== Fedora の特徴 ==
note over Kernel, GUIApp
- 最新技術やソフトウェアを重視
- パッケージ管理: dnf/rpm
- デフォルト DE: GNOME
- Red Hat 系で開発向き、アップデート頻繁
end note

== Debian の特徴 ==
note over Kernel, GUIApp
- 安定性最優先、長期サポート
- パッケージ管理: apt/dpkg
- デフォルト DE: GNOME, Xfce など選択可
- 保守的、サーバ利用に向く
end note

== NixOS の特徴 ==
note over Kernel, GUIApp
- 宣言的設定、完全再現性重視
- パッケージ管理: nix / nixpkgs
- DE は自由に選択可能 (GNOME, KDE, Xfce, i3 など)
- 設定はFlakeやconfiguration.nixで一元管理
- 開発者・上級者向け、環境再現性に優れる
end note

@enduml

@startuml
title Linux: カーネルからアプリまで（Shell と DE 内アプリ含む）

actor User
participant Kernel as "Linux Kernel"
participant Shell as "Shell / Terminal"
participant ShellApp as "CLI アプリ (vim, emacs, htop)"
participant DMDE as "Display Manager / Desktop Environment"
participant GUIApp as "GUI アプリ (ブラウザ, エディタ, IDE)"

== 流れ ==
User -> Kernel : システムコールを発行
Kernel -> Shell : CLI操作を提供
Shell -> ShellApp : CLIアプリを実行
Kernel -> DMDE : GUI表示とデスクトップ環境提供
DMDE -> GUIApp : GUIアプリを表示・操作

note over Kernel
カーネルはハードウェアとユーザー空間の仲介者
end note

note over Shell
シェルはCLI操作の窓口、CLIアプリを起動
end note

note over ShellApp
ターミナル内で動くアプリ例: vim, emacs, htop
end note

note over DMDE
Display ManagerとDesktop EnvironmentはGUI操作の窓口
標準アプリも内包 (ファイルマネージャ, 端末, 設定ツール)
end note

note over GUIApp
ユーザーが追加で使うGUIアプリ例: ブラウザ, エディタ, IDE
end note

@enduml

@startuml
title Linux: カーネルからアプリまで（シンプル版）

actor User
participant Kernel as "Linux Kernel"
participant Shell as "Shell / Terminal"
participant DMDE as "Display Manager / Desktop Environment"
participant App as "Applications"

== 流れ ==
User -> Kernel : システムコールを発行
Kernel -> Shell : CLI操作やコマンド提供
Kernel -> DMDE : GUI表示とデスクトップ環境提供
Shell -> App : CLIアプリを実行
DMDE -> App : GUIアプリを表示・操作

note over Kernel
カーネルはハードウェアとユーザー空間の仲介者
end note

note over Shell
シェルはCLI操作の窓口、コマンドや開発ツールを提供
end note

note over DMDE
Display ManagerとDesktop EnvironmentはGUI操作の窓口
end note

note over App
アプリケーション例: ブラウザ, エディタ, IDE, メディアプレイヤー
end note

@enduml

@startuml
title Linux: カーネルとハードウェアの関係（シーケンス図）

actor "ユーザー空間 (User Space)" as User
participant "Linux Kernel" as Kernel
participant "ハードウェア (Hardware)" as HW

== システム動作の流れ ==

User -> Kernel : システムコールを発行\n(例: ファイル操作・プロセス作成)
Kernel -> HW : デバイスドライバを通じて操作\n(例: ディスクI/O・ネットワーク送信)
HW --> Kernel : 実行結果や割り込みを返す
Kernel --> User : 戻り値・処理結果を返す

note over Kernel
カーネルは「仲介者」\nハードウェアを直接触らずに安全に操作するための層
end note

@enduml

@startuml
title Linux: カーネルと上位レイヤーの選択肢（シーケンス図）

actor "ユーザー空間 (User Space)" as User
participant "Linux Kernel" as Kernel
participant "ディストリビューション (Distribution)" as Distro
participant "初期化 / サービス (Init/Service)" as Init
participant "パッケージ管理 (Package Manager)" as Pkg
participant "シェル / ターミナル (Shell/Terminal)" as Shell
participant "デスクトップ / GUI (DM/DE)" as GUI
participant "アプリケーション (Applications)" as App

== カーネルと上位層の流れ ==

User -> Kernel : システムコールを発行
Kernel -> Distro : 基本機能を提供
Distro -> Init : 起動とサービス管理を選択
Distro -> Pkg : ソフトウェア管理を選択
Distro -> Shell : 標準シェル・ターミナルを選択
Distro -> GUI : DM と DE を選択
GUI -> App : ユーザー向けアプリを提供
Shell -> App : CLI 操作や開発ツールを提供
Pkg -> App : パッケージからアプリを提供

== 選択肢の例 ==

note over Distro
ディストリビューション例:
- Ubuntu: 初心者向け・安定
- Arch: カスタマイズ自由
- NixOS: 宣言的設定
end note

note over Init
Init system例:
- systemd (標準)
- runit, openrc, s6 (軽量派)
end note

note over Pkg
パッケージ管理例:
- apt/dpkg (Debian系)
- dnf/rpm (Fedora系)
- pacman (Arch)
- nix (NixOS)
end note

note over Shell
シェル/ターミナル例:
- bash, zsh, fish
- gnome-terminal, alacritty, konsole
end note

note over GUI
GUI例:
- DM: gdm, sddm, lightdm, ly
- DE: GNOME, KDE, Xfce, LXQt, i3/sway
end note

note over App
アプリ例:
- ブラウザ, エディタ, IDE, メディアプレイヤー
end note

@enduml



@startuml
skinparam dpi 150
skinparam defaultFontName Arial
hide empty description

title Linux: カーネルのみ（シンプル表示）

package "ハードウェア" as HW {
  [CPU・メモリ・ディスク・ネットワーク]
}

package "カーネル" as K {
  [Linux Kernel (ハードウェアとユーザー空間の橋渡し)]
}

HW --> K

note bottom of K
  カーネルはプロセス管理、メモリ管理、デバイス制御、ネットワークなどを担当
end note

@enduml


@startuml
title 自転車青切符制度と「国民不在」の情報構造

actor 国民
participant メディア
participant 国会
participant 警察庁
participant 有識者
participant 政府

== 第1段階：内部検討 ==
警察庁 -> 有識者 : 取締り効率化について協議
有識者 -> 警察庁 : 青切符制度を提案
note right
国民の意見を聞く前に方向性が固まる
end note

== 第2段階：形式的なパブリックコメント ==
警察庁 -> 国民 : Web上で意見募集（告知は限定的）
国民 -> 警察庁 : 一部のみ意見提出
note over 警察庁
集まった意見は政策にほとんど反映されない
end note

== 第3段階：政策決定と報道 ==
警察庁 -> 国会 : 計画と実施時期を報告
国会 -> 政府 : 承認し、告知を指示
政府 -> メディア : 資料とプレスリリースを提供
メディア -> 国民 : 「来年から青切符制度開始」と報道
note over 政府, メディア
【情報のボトルネック】
・政府と旧来メディアが情報を独占  
・決定後に一方的に発表  
・公開討論の仕組みが存在しない
end note

== 第4段階：国民の反応 ==
国民 -> 国民 : 「えっ、いつ決まったの!?」
note over 国民
多くの国民は初めて報道で知る  
→ 意思決定に関われない構造
end note

== 第5段階：望ましい構造 ==
国民 -> 政府 : 「決定前に議論を！」
メディア -> 国民 : 賛否両論や背景を報道
警察庁 -> 国民 : 目的と安全効果を説明
note over 国民, メディア
【理想的な姿】
・決定前に情報共有と対話  
・メディアは広報ではなく議論の場に  
・国民が「知らせる側」にも回る社会
end note
@enduml


@startuml
' ===========================================================
' Bicycle Blue Ticket System - Missing Public Discussion
' ===========================================================

' 自転車青切符制度と国民不在の情報構造
title Bicycle Blue Ticket System - Info Flow Problem

actor Citizen
participant Media
participant Parliament
participant PoliceAgency
participant Experts
participant Gov as Government

== Step 1: Internal Planning ==
PoliceAgency -> Experts : Discuss enforcement efficiency
Experts -> PoliceAgency : Suggest blue ticket system
note right
Direction decided internally without citizen input
end note

== Step 2: Formal Public Comment ==
PoliceAgency -> Citizen : Announce public comment online (low visibility)
Citizen -> PoliceAgency : Few opinions submitted
note over PoliceAgency
Little reflection of public feedback
end note

== Step 3: Policy Decision and Announcement ==
PoliceAgency -> Parliament : Report plan and schedule
Parliament -> Government : Approve and instruct for public notice
Government -> Media : Provide documents and press release
Media -> Citizen : News: "Blue ticket system starts next year"
note over Government, Media
[Information bottleneck]
- Government and legacy media control the info flow  
- Only post-decision announcements  
- No structure for open discussion
end note

== Step 4: Citizen Reaction ==
Citizen -> Citizen : "Wait, when was this decided?"
note over Citizen
Citizens receive notice, not participate in decision
end note

== Step 5: Ideal Future ==
Citizen -> Government : "Dialogue before announcement"
Media -> Citizen : Report pros, cons, and context
PoliceAgency -> Citizen : Explain safety goals
note over Citizen, Media
[Ideal]
- Share info before decision  
- Media acts as discussion space, not PR  
- Citizens become co-thinkers, not mere recipients
end note

@enduml




@startuml
' ==========================================================
'  シーケンス図：自転車青切符制度に対する「不快感の構造」
' ==========================================================

title 自転車青切符制度の導入プロセスと国民の違和感

actor 国民
participant 報道機関
participant 警察庁
participant 国会
participant 有識者会議

== 第1段階：行政内部での立案 ==
警察庁 -> 有識者会議 : 「自転車違反を取り締まりやすくしたい」
有識者会議 -> 警察庁 : 「青切符制度を導入すべき」と提言
note right: この段階では国民の参加はない

== 第2段階：形式的な意見募集 ==
警察庁 -> 国民 : パブリックコメントをWEBで公示（気づく人は少数）
国民 -> 警察庁 : 一部の意見が届くが、反映は限定的
note over 警察庁 : 実質的には「確認のための手続き」

== 第3段階：制度決定と施行 ==
警察庁 -> 国会 : 閣議決定・施行時期を報告
国会 -> 警察庁 : 了承（形式的な審議）
警察庁 -> 報道機関 : 「来年から青切符導入」と発表

== 第4段階：国民の受け止め ==
報道機関 -> 国民 : 「違反すれば罰金」のニュースを報道
国民 -> 国民 : 「え？いつ決まったの？」「説明聞いてない」
note over 国民 : 制度の目的よりも「いきなり決まった感」が先に来る

== 第5段階：本来あるべき姿（理想） ==
国民 -> 警察庁 : 「事故防止が目的なら教育やインフラ整備も必要」
警察庁 -> 国民 : 「次回は意見反映を検討します（予定）」
note over 国民,警察庁
  理想：事前の議論と合意
  現実：事後の告知と既成事実化
end note

@enduml


@startuml
actor 国民
participant ネット世論
participant 自民党
participant 高市総裁
participant 公明党
participant 野党勢力
participant 報道機関

== 連立解消の決断 ==
高市総裁 -> 公明党 : 「連立を解消する」と通告
自民党 -> 国民 : 「公明との連立を解消」と発表
報道機関 -> 国民 : 大きく報道

== ネット世論の反応 ==
ネット世論 -> 高市総裁 : 「筋を通した」と支持
ネット世論 -> 自民党 : 「よくやった！」の声多数

== 政権運営フェーズ ==
alt 自民党 単独で過半数維持
  自民党 -> 国民 : 単独政権を続行
  報道機関 -> 国民 : 「自民単独政権」と解説
else 過半数割れ
  自民党 -> 野党勢力 : 協力や新連立を模索
  公明党 -> 野党勢力 : 協力を探る動き
  報道機関 -> 国民 : 「政界再編の可能性」と報道
end

== 選挙への影響 ==
国民 -> 自民党 : 一部選挙区で苦戦
国民 -> 公明党 : 支持母体で結束強化
ネット世論 -> 国民 : 「変化を求める世論」が拡散

@enduml


@startuml
actor 国民
participant ネット世論
participant 自民党
participant 高市総裁
participant 公明党
participant 報道機関

== 現状 ==
自民党 -> 公明党 : 連立維持・選挙協力
公明党 -> 自民党 : 政策協力を提供
報道機関 -> 国民 : 「自公連立の摩擦」を報道

== ネット世論の声 ==
ネット世論 -> 自民党 : 「公明党と手を切れ！」の圧力
ネット世論 -> 高市総裁 : 「公明党と距離を置け」と期待

== 自民党内議論 ==
高市総裁 -> 自民党 : 保守色強化を主張
自民党 -> 公明党 : 関係再考のシグナル

== 公明党の反応 ==
公明党 -> 自民党 : 「それなら連立解消も検討」と応答
報道機関 -> 国民 : 「連立解消の可能性」を大きく報道

== 将来の決定 ==
alt 自民が公明と決別
  自民党 -> 国民 : 「公明と連立解消」と発表
  高市総裁 -> 国民 : 「自民は独自路線で行く」と強調
else 維持
  自民党 -> 公明党 : 「やはり連立維持」と確認
  報道機関 -> 国民 : 「連立継続」と報道
end

@enduml


@startuml
actor 国民
participant 自民党
participant 公明党
participant 報道機関

== 現状 ==
国民 -> 自民党 : 政権運営を委ねる（選挙）
自民党 -> 公明党 : 連立維持を打診
公明党 -> 自民党 : 政策協力を実施

== 問題の発生 ==
報道機関 -> 国民 : 「政治とカネ」問題を報道
公明党 -> 自民党 : 説明と対応を要求
自民党 -> 公明党 : 明確な対応を示せず摩擦

== 協議フェーズ ==
公明党 -> 公明党 : 幹部会で協議
alt 連立解消論が強まる
  公明党 -> 自民党 : 「連立解消もやむなし」と伝達
  報道機関 -> 国民 : 「連立解消の可能性」と報道
else 連立維持論が勝る
  公明党 -> 自民党 : 「連立維持」を確認
  報道機関 -> 国民 : 「連立継続」と報道
end

== 将来の決定 ==
alt 解消決定
  公明党 -> 国民 : 「自民との連立を解消する」と発表
  自民党 -> 国民 : 単独政権 or 新連立の模索
else 維持決定
  公明党 -> 国民 : 「自民との連立を継続」と発表
  自民党 -> 国民 : 安定政権を強調
end

@enduml


@startuml

[*] --> 連立関係安定

state 連立関係安定 {
}

state 離脱検討中 {
}

state 連立解消決定 {
}

state 連立維持決定 {
}

連立関係安定 --> 離脱検討中 : 新たな論点・対立
離脱検討中 --> 連立解消決定 : 党として離脱判断
離脱検討中 --> 連立維持決定 : 継続判断
連立維持決定 --> 連立関係安定

@enduml


@startuml
title Windows 10 サポート終了対応シーケンス図

actor "ユーザー" as User
participant "Windows 10 PC" as PC
participant "サポート情報サイト" as Info
participant "判断ロジック\n(社内・個人ポリシー)" as Policy
participant "ネットワーク管理者\nまたは設定担当" as Admin
participant "代替OS検討者" as AltOS
participant "ログ/記録システム" as Log

== サポート終了確認 ==
User -> Info : Microsoft公式サポート終了日を確認
Info --> User : 終了日(2025-10-14予定など)

== 使用状況チェック ==
User -> PC : 現在の用途を確認（メイン/サブ）
User -> Policy : 使用ソフトのサポート継続可否を照会
Policy --> User : 結果（継続可能 / 終了）

== 判定フェーズ ==
alt ソフト・セキュリティ両方継続不可
    User -> Admin : ネット遮断要求
    Admin -> PC : オフライン化（LAN/無線停止）
    User -> AltOS : 代替OS（Linuxなど）検討開始
    AltOS -> Log : 検討開始ログを記録
else ソフトは利用可能だがネットリスクあり
    User -> Admin : 制限付き接続に変更（更新停止・外部通信制限）
    Admin -> Log : 制限設定を記録
else 問題なし（限定利用）
    User -> Log : 状況記録（限定的継続使用）
end

== 移行・記録 ==
User -> AltOS : 新環境へ移行手順の準備
AltOS -> Log : 移行日程・完了記録
Log --> User : 全対応完了通知

@enduml

@startuml
title 「旧メディア印象操作の簡略図＋改善策」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 13
skinparam sequenceParticipantPadding 20
skinparam sequenceMessageSpacing 12

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア" as OldMedia
participant "国民（SNS含む）" as Citizens

== 裏側での発言,音声流出 ==
KishaClub -> KishaClub : 「政治家を悪く見せる写真を撮ろう」「印象を悪くする記事を書いてやる」  
KishaClub -> Citizens : オフレコ音声が流出・拡散

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた記事・映像を報道

== 炎上 ==
Citizens -> OldMedia : 信頼低下・批判拡散
Citizens -> KishaClub : 信頼低下・批判拡散

== 記者クラブの問題点 ==
note over KishaClub
  ・政治家へのアクセスを独占  
  ・閉鎖的な組織で内部情報を握る  
  ・取材競争が少なく、影響力が強い  
  → 印象操作や記事の恣意的編集が可能
end note

== 改善・改革案 ==
note over KishaClub, OldMedia
  ・政治家との情報共有の透明化  
  ・取材機会の平等化（フリーランス・ネットメディアも参加）  
  ・記事・映像のチェック体制強化（内部/外部監査）  
  ・誤報・印象操作の迅速な訂正  
  ・市民参加型のフィードバックや苦情受付  
  → 信頼回復と公正な報道を目指す
end note

@enduml


@startuml
title 「旧メディア印象操作の簡略図（裏側発言＋記者クラブの前提）」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 13
skinparam sequenceParticipantPadding 20
skinparam sequenceMessageSpacing 12

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア" as OldMedia
participant "国民（SNS含む）" as Citizens

== 裏側での発言,音声流出 ==
KishaClub -> KishaClub : 「政治家を悪く見せる写真を撮ろう」「印象を悪くする記事を書いてやる」  
KishaClub -> Citizens : オフレコ音声が流出・拡散

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた記事・映像を報道

== 炎上 ==
Citizens -> OldMedia : 信頼低下・批判拡散
Citizens -> KishaClub : 信頼低下・批判拡散

== 記者クラブの問題点 ==
note over KishaClub
  ・政治家へのアクセスを独占  
  ・閉鎖的な組織で内部情報を握る  
  ・取材競争が少なく、影響力が強い  
  → 印象操作や記事の恣意的編集が可能
end note

@enduml


@startuml
title 「旧メディア印象操作の簡略図（裏側発言あり）」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 13
skinparam sequenceParticipantPadding 20
skinparam sequenceMessageSpacing 12

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア" as OldMedia
participant "国民（SNS含む）" as Citizens

== 裏側での発言 ==
KishaClub -> KishaClub : 「政治家を悪く見せる写真を撮ろう」  
KishaClub -> KishaClub : 「印象を悪くする記事を書いてやる」

== 音声流出 ==
KishaClub -> Citizens : オフレコ音声が流出・拡散

== 炎上 ==
Citizens -> OldMedia : 信頼低下・批判拡散

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた記事・映像を報道

@enduml


@startuml
title 「旧メディアの印象操作と国民への影響」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 13
skinparam sequenceParticipantPadding 25
skinparam sequenceMessageSpacing 15

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア(新聞・テレビ)" as OldMedia
participant "国民（SNS/ネットユーザー含む）" as Citizens

== 裏側での発言 ==
KishaClub -> KishaClub : 政治家を悪く見せる算段

== 音声流出 ==
KishaClub -> Citizens : オフレコ音声が流出・拡散
note right of Citizens
  「印象操作してる！」と炎上
end note

== 炎上 ==
Citizens -> OldMedia : 信頼を失う
Citizens -> Politician : 支持/同情も発生

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた記事・映像を報道
note right of Citizens
  世論誘導を受けつつ  
  ネットで批判・議論
end note

@enduml


@startuml
title 「旧メディアの印象操作と国民への影響」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 14
skinparam sequenceParticipantPadding 35
skinparam sequenceMessageSpacing 25

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア(新聞・テレビ)" as OldMedia
participant "国民（SNS/ネットユーザー含む）" as Citizens

== 裏側での発言 ==
KishaClub -> KishaClub : 「政治家を悪く見せる写真を撮ろう」  
KishaClub -> KishaClub : 「印象を悪くする記事を書いてやる」

== 音声流出 ==
KishaClub -> Citizens : オフレコ音声がネットに流出
note right of Citizens
  国民がSNSで音声を拡散  
  「旧メディアは印象操作している！」  
end note

== 炎上 ==
Citizens -> Citizens : 怒り・拡散・批判

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた情報を報道
note right of Citizens
  ・印象操作された記事や映像を受け取る  
  ・一方的な世論誘導を受ける  
end note

== 信頼低下 ==
Citizens -> OldMedia : 「旧メディアは信用できない」  
OldMedia -> OldMedia : ブランド失墜・不信感拡大
Politician -> Politician : 一時的にイメージ悪化

== 根本原因の議論 ==
note over Citizens
  ネット上で議論拡大：  
  ・記者クラブという閉鎖的システムが問題  
  ・公平・公正な報道を妨げている  
  ・旧メディア不信の源泉  
end note

@enduml


@startuml
title 「旧メディアの印象操作と国民への影響」

skinparam defaultFontName "Arial"
skinparam defaultFontSize 14
skinparam sequenceParticipantPadding 35
skinparam sequenceMessageSpacing 25

actor "政治家" as Politician
participant "記者クラブ（記者＋カメラマン）" as KishaClub
participant "旧メディア(新聞・テレビ)" as OldMedia
participant "SNS/ネットユーザー" as NetUser
participant "国民" as Citizens

== 裏側での発言 ==
KishaClub -> KishaClub : 「政治家を悪く見せる写真を撮ろう」  
KishaClub -> KishaClub : 「印象を悪くする記事を書いてやる」

== 音声流出 ==
KishaClub -> NetUser : 内部音声が流出
note right of KishaClub
  オフレコのやり取りがネットに流出
end note

== 炎上 ==
NetUser -> NetUser : 怒り・拡散
note right of NetUser
  「旧メディアは印象操作している！」  
  「公正な報道じゃない！」  
end note

== 歪んだ情報の伝達 ==
OldMedia -> Citizens : 歪められた情報を報道
note right of Citizens
  ・印象操作された記事や映像を受け取る  
  ・世論が誘導される  
end note

== 信頼低下 ==
NetUser -> OldMedia : 信頼を失う
OldMedia -> OldMedia : ブランド失墜・不信感拡大
Politician -> Politician : 一時的にイメージ悪化

== 根本原因の議論 ==
note over NetUser, Citizens
  ネット上では炎上を超えて議論に発展  
  ・記者クラブという閉鎖的システムが問題  
  ・公平・公正な報道を妨げている  
  ・旧メディア不信の本当の源泉  
end note

@enduml


@startuml
title 「旧メディアの印象操作」炎上と記者クラブ批判の構造

skinparam defaultFontName "Arial"
skinparam defaultFontSize 14
skinparam sequenceParticipantPadding 35
skinparam sequenceMessageSpacing 25

actor "政治家" as Politician
participant "記者クラブ記者" as Reporter
participant "カメラマン" as Cameraman
participant "旧メディア(新聞・テレビ)" as OldMedia
participant "SNS/ネットユーザー" as NetUser

== 裏側での発言 ==
Reporter -> Cameraman : 「政治家を悪く見せる写真を撮ろう」
Reporter -> Reporter : 「印象を悪くする記事を書いてやる」

== 音声流出 ==
Reporter -> NetUser : 内部音声が流出
note right of Reporter
  オフレコのやり取りがネットに流出
end note

== 炎上 ==
NetUser -> NetUser : 怒り・拡散
note right of NetUser
  「旧メディアは最初から印象操作している」  
  「報道は公正ではない」  
end note

== 信頼低下 ==
NetUser -> OldMedia : 信頼を失う
OldMedia -> OldMedia : ブランド失墜・不信感拡大
Politician -> Politician : 一時的にイメージ悪化

== 根本原因の議論 ==
note over NetUser
  ネット上では炎上を超えて議論に発展  
  ・記者クラブという閉鎖的システムが問題  
  ・公平・公正な報道を妨げている  
  ・旧メディア不信の本当の源泉  
end note

@enduml


@startuml
title 「旧メディアが印象操作をしている音声流出」炎上構造

skinparam defaultFontName "Arial"
skinparam defaultFontSize 14
skinparam sequenceParticipantPadding 35
skinparam sequenceMessageSpacing 25

actor "政治家" as Politician
participant "記者クラブ記者" as Reporter
participant "カメラマン" as Cameraman
participant "旧メディア(新聞・テレビ)" as OldMedia
participant "SNS/ネットユーザー" as NetUser

== 裏側での発言 ==
Reporter -> Cameraman : 「政治家を悪く見せる写真を撮ろう」
Reporter -> Reporter : 「印象を悪くする記事を書いてやる」

== 音声流出 ==
Reporter -> NetUser : 内部音声が流出
note right of Reporter
  オフレコの会話が録音されネットに流出
end note

== 炎上 ==
NetUser -> NetUser : 怒り・拡散
note right of NetUser
  「旧メディアは最初から印象操作している」  
  「報道は公正ではない」  
end note

== 信頼低下 ==
NetUser -> OldMedia : 信頼を失う
OldMedia -> OldMedia : ブランド失墜・不信感拡大
Politician -> Politician : 一時的にイメージ悪化
note over OldMedia, NetUser
  炎上の主因は旧メディア側への不信感  
  政治家本人よりも「報道の公正性」が問題視される
end note

@enduml


@startuml
!theme plain

title 国民と旧来型メディアの「信頼 ⇔ 不信」構造

participant 国民
participant 旧来型メディア

== 信頼層（理想的関係） ==
国民 -> 旧来型メディア: 情報を信頼し、社会を理解する
旧来型メディア -> 国民: 公正・中立な報道、権力監視、事実検証

note over 国民,旧来型メディア: 双方に信頼の循環がある

== 断絶 ==
note over 国民,旧来型メディア: SNS台頭・誤報・偏向報道・既得権益の露呈

== 不信層（現実の関係） ==
旧来型メディア -> 国民: 扇動的報道、視聴率優先、政治的編集
国民 -> 旧来型メディア: 不信・批判・離反（テレビ離れ・紙離れ）
国民 -> 国民: SNSで事実検証・独自情報共有（メディア不在の情報空間）

note over 国民: 「もはや自分で確かめるしかない」という諦念と覚醒が混在
@enduml


@startuml
!theme plain

title 信頼 ⇔ 不信 の構造（2025 政治・報道・国民）

participant 国民
participant 政治
participant メディア

== 信頼層 ==
国民 -> 政治: 期待・支持
政治 -> 国民: 説明責任・成果報告
メディア -> 国民: 公平報道・検証

== 断絶 ==
note over 国民, 政治: 疑念・説明不足・報道不信

== 不信層 ==
国民 -> 政治: 無関心・批判
政治 -> メディア: 圧力・敵視
メディア -> 国民: 扇動的報道・断片的情報
国民 -> メディア: SNSでの反発・不信感
@enduml


@startuml
title ブロックチェーンによる税金使途の可視化フロー

start

partition "市民(支払者)" {
:支払い（商品代金）;
}

partition "ウォレット" {
:トランザクション作成（用途タグを付与）;
}

partition "スマートコントラクト" {
fork
:税額自動計算;
fork again
:分配先アドレス決定;
fork again
:支払・分配命令を発行;
end fork
}

partition "ブロックチェーン(台帳)" {
:トランザクション永続化\n(取引ID, タグ, ハッシュ);
if (即時入金成功?) then (yes)
:税の受領を記録;
else (no)
:リトライまたはエラーログ;
stop
endif
}

partition "税務当局" {
:入金確認と予算科目への割当;
:使途タグに基づく予算執行要求を公開;
if (使途承認が必要?) then (yes)
partition "担当部署" {
:執行申請の審査;
:承認 or 差戻し;
}
endif
}

partition "監査ノード" {
:定期スキャン（タグ別集計）;
:異常検出時にアラート生成;
}

stop
@enduml


@startuml
title 税の自動算出と分配フロー（ブロックチェーン版）

actor "市民(支払者)" as User
participant "マーチャント\n(販売者)" as Merchant
participant "ウォレット\n(支払者)" as Wallet
participant "スマートコントラクト\n(TaxSplitter)" as Contract
participant "ブロックチェーン\n(台帳)" as Ledger
participant "税務当局" as TaxAuthority
participant "監査ノード\n(Auditor)" as Auditor

== 購入と税額算出 ==
User -> Merchant : 商品購入リクエスト
Merchant -> Wallet : 請求情報 (金額, 税率, 用途タグ)
Wallet -> Contract : 支払いトランザクション（額＋メタデータ）
Contract -> Contract : 税率適用・分配額計算

== 自動分配 ==
Contract -> Ledger : 税（国税）トランザクション記録 (タグ: 国税)
Contract -> Ledger : 地方税トランザクション記録 (タグ: 地方税)
Contract -> Ledger : 支払者・受取者・用途タグを含むメタデータ保存
Contract -> TaxAuthority : 通知（入金確定、取引ID）

== 透明性と検証 ==
Ledger -> Auditor : ブロックチェーンの読み取り（ハッシュ/トランザクションID）
Auditor -> TaxAuthority : 監査レポート（不整合検出時アラート）
Auditor -> User : 公開ビュー（使途タグ別の集計）

note right of Ledger
すべてのトランザクションは
改ざん不可能な形で台帳に残る
end note
@enduml


@startuml
' PlantUML: Sequence diagram with two major branches for the Prime Minister's decision flow
' Shows two alternative paths: 1) 連立継続 (coalition remains) 2) 連立解消 (coalition dissolved)

skinparam sequenceMessageAlign center
skinparam sequenceParticipantPadding 10
skinparam sequenceLifeLineBorderColor Black
skinparam sectionFontSize 14

title 高市総理（仮） の意思決定フロー — 連立維持 vs 連立解消

participant "有権者\n(Voters)" as V
participant "総理 (高市)\nPrime Minister" as PM
participant "自民党\n(LDP)" as LDP
participant "公明党\n(Komei)" as KOMEI
participant "維新/第三極\n(Options)" as ISHIN
participant "官僚/省庁\n(Bureaucracy)" as B
participant "国会/野党\n(Parliament)" as DIET
participant "メディア\n(Media)" as M

== 健全: 情報収集・意思決定準備 ==
V -> PM: 世論の反応・要望
PM -> B: 情報収集（影響分析・リスク評価）
B -> PM: 政策案とインパクト試算
PM -> LDP: 党内説明・調整
LDP -> PM: 内部合意の有無を報告

== 意思決定: 主要分岐 (alt: 連立維持 / 連立解消) ==
alt 連立維持
  PM -> KOMEI: 継続協議（譲歩/条件提示）
  KOMEI -> PM: 条件付き承認または追加要求
  PM -> LDP: 妥協案提示
  LDP -> PM: 党内承認
  note right of PM
    連立継続を選んだ場合の流れ
  end note
  PM -> DIET: 政策提出・説明
  DIET -> DIET: 採決・成立の試み
  DIET -> M: 成果の広報
else 連立解消
  PM -> KOMEI: 連立解消・関係再定義
  KOMEI -> PM: 閣外協力か独自路線かの決断
  PM -> LDP: 緊急会議（後続戦略）
  PM -> ISHIN: 新たな連携の打診/交渉
  ISHIN -> PM: 条件提示または拒否
  PM -> B: 緊急政策調整・代替案作成
  PM -> DIET: 臨時国会や協議の要請
  note right of PM
    連立解消を選んだ場合の流れ（不確実性・混乱リスク高）
  end note
  DIET -> M: 政局報道・世論反応の増幅
end

== 結果の短期影響 (opt) ==
opt 連立維持の短期影響
  M -> V: 安定感の演出（または批判）
  DIET -> B: 予算・政策遂行の継続
  note over DIET,B
    政策実行の速度はやや緩慢だが安定性は保たれる
  end note
end

opt 連立解消の短期影響
  M -> V: 不安感・不確実性の拡大
  V -> DIET: 批判・支持率低下の反応
  DIET -> B: 予算可決や法案成立の遅延
  note over DIET,B
    市場や行政、外交への波及も懸念される
  end note
end

== 中長期の分岐とガバナンスリスク ==
PM -> LDP: 政党戦略の再構築（候補者調整、選挙戦略）
PM -> M: 政権の説明責任を果たすための広報

== 下層: 誹謗中傷/対立の拡大 ==
M -> V: 扇動的報道や断片的情報の流布
V -> PM: 攻撃的な反応・信頼失墜
PM -> DIET: 強硬対応・法的措置の検討
DIET -> PM: 政治的コストと法的リスクの増大

@enduml


@startuml
' PlantUML: Sequence diagram with section dividers
' Visualizes: higher = constructive discussion, lower = abusive/toxic
' Use == Section == lines to separate levels vertically.

skinparam sequenceMessageAlign center
skinparam sequenceParticipantPadding 10
skinparam sequenceLifeLineBorderColor Black
skinparam sectionFontSize 14

title 可視化: 上が健全・下が誹謗中傷 の議論スケール

participant User as U
participant "Participant A\n(発言者)" as A
participant "Participant B\n(反論者)" as B
participant Moderator as M
participant System as S

== 健全: 課題提示・情報提供 ==
U -> A: 質問（事実確認）
A -> U: 回答（根拠付き）
note right of A
  事実と根拠を示す発言
end note

== 建設的: 意見交換・反論 ==
U -> B: 反論・追加質問
B -> A: 具体例を提示して反論
A -> B: 補足・謝意
note left of B
  論点に基づく反論・感情は控えめ
end note

== 偏向・感情化: 個人攻撃に近づく兆候 ==
B -> A: 強い否定（感情的）
A -> M: 仲裁要請
M -> B: 発言の落ち着きを促す
note right of M
  モデレーションが必要になる段階
end note

== 下層: 誹謗中傷・人格否定 ==
B -> A: 人格攻撃（侮辱）
A -> S: モデレーション報告
S -> M: 自動警告（アルゴリズム）
M -> B: 一時的な発言停止・注意
note over B,A
  コミュニティガイドライン違反の可能性
end note

' Optional: loop to show escalation path
loop エスカレーションの流れ
  B -> A: エスカレーション
  A -> M: 報告
  M -> B: 対応（警告/停止/教育）
end

@enduml

@startuml
title PINを拒否してパスワードを優先させる流れ（日本語）

actor ユーザー
participant "サインイン画面\n(ロック画面)" as Signin
participant "サインイン オプション\n(鍵アイコン等)" as Options
participant "設定\n(アカウント→サインイン オプション)" as Settings
participant "Ngcフォルダー\n(PINデータ)" as Ngc
participant "グループポリシー / MDM\n(組織管理)" as Policy
participant "再起動/キャッシュ" as Cache

ユーザー -> Signin: PCを起動してサインイン画面表示
Signin -> ユーザー: デフォルトでPIN入力欄を表示
ユーザー -> Signin: 「サインイン オプション」を選択
Signin -> Options: 利用可能な方法を表示（PIN/パスワード等）
Options -> ユーザー: パスワードアイコンを選択できるか？
alt パスワードが選べる場合
  ユーザー -> Signin: パスワードでサインイン（回避成功）
  Signin -> Settings: （任意）ログイン後にSettingsを開く
  Settings -> Ngc: PINを削除する操作を実行（推奨）
  Ngc -> Settings: 削除成功
  Settings -> ユーザー: 次回からパスワードが優先表示される
else パスワードが選べない／グレーアウトの場合
  Options -> Policy: ポリシー確認（PINが強制されているか）
  alt ポリシーで強制されている場合
    Policy -> ユーザー: 管理者に相談が必要（個人で解除不可）
  else ポリシーによる強制でない場合
    Settings -> Ngc: Ngcリセット（管理者コマンドで削除）
    Ngc -> Cache: キャッシュの影響をクリア
    Cache -> Signin: サインイン画面を更新
    Signin -> ユーザー: パスワードが選べるようになる
  end
end

note right of Ngc
Ngcリセットは管理者権限が必要:
takeown /f "...Ngc" /r /d y
icacls "...Ngc" /grant Administrators:F /t
rmdir /s /q "...Ngc"
再起動を忘れずに
end note

@enduml


@startuml
title サインイン方法変更: PIN→パスワードにしたのにパスワードが選べない

actor ユーザー
participant "設定\n[アカウント > サインイン オプション]" as Settings
participant "ローカル アカウント\n(資格情報ストア)" as LocalStore
participant "Ngc フォルダー\n(PINデータ)" as Ngc
participant "資格情報プロバイダー\n(Winlogon)" as CredProv
participant "サインイン画面\n(ロック画面)" as Signin
participant "グループ ポリシー / MDM" as Policy
participant "Windows Update / キャッシュ" as Cache

ユーザー -> Settings: Microsoft アカウント → ローカル アカウントに切替\nPINを削除したつもり
Settings -> Ngc: PIN削除処理
Ngc -> LocalStore: PINデータ残存の可能性
Ngc --> Settings: 削除成功/失敗の状態
Settings -> CredProv: 優先サインイン方法を更新
Policy -> CredProv: (組織ポリシーがPINを強制する場合あり)
Cache -> Signin: サインイン画面のUI状態をキャッシュ
CredProv -> Signin: 利用可能なサインイン方法を列挙
Signin -> ユーザー: PINのみ表示（パスワード非表示）

note over Policy,Ngc
考えられる要因:
- NgcフォルダーにPINデータが残っている
- 資格情報プロバイダーがPINを優先表示
- グループポリシー/MDMでPIN必須
- キャッシュやWindowsの不具合
end note
@enduml


@startuml
title Sign-in flow: PIN->Password changed but Password not selectable

actor User
participant "Settings\n(Sign-in options)" as Settings
participant "Local Account\n(OS Credential Store)" as LocalStore
participant "Ngc\n(PIN data folder)" as Ngc
participant "Credential Providers\n(Winlogon / GINA)" as CredProv
participant "Sign-in Screen\n(Lock screen)" as Signin
participant "Group Policy / MDM" as Policy
participant "Windows Update / Cache" as Cache

User -> Settings: Switch MS account -> Local account\nRemove/disable PIN?
Settings -> Ngc: Attempt to remove PIN
Ngc -> LocalStore: PIN data present (may be cached)
Ngc --> Settings: Removal succeeded/failed
Settings -> CredProv: Update preferred sign-in method
Policy -> CredProv: (may enforce PIN / Hello)
Cache -> Signin: Cached credential UI state (still shows PIN)
CredProv -> Signin: Populate available options\n(order: PIN first if present)
Signin -> User: Shows PIN option (Password not shown)
User -> Signin: Open "Sign-in options"
Signin -> CredProv: Query available providers
CredProv -> LocalStore: Check Password provider availability
LocalStore --> CredProv: Password provider available
CredProv -> Signin: But UI hides/selects PIN by default\n(or Password option disabled by policy)
Signin -> User: Password not selectable (grayed or missing)

note over Policy,Ngc: Possible causes:
note over Policy,Ngc: - Ngc (PIN) still exists or cached\n- Credential provider order prefers PIN\n- Group Policy / MDM enforces Hello/PIN\n- Corrupted settings or Windows bug
@enduml


@startuml
title TPMが役立つ非盗難シナリオ

actor "攻撃者(リモート/ローカル)" as Att
participant "マシン" as Host
participant "OS" as OS
participant "TPM 2.0" as TPM

== ブート改ざん（rootkit） ==
Att -> OS: 不正ブートローダ書換試行
OS -> TPM: 起動計測値を読み出し/比較
TPM --> OS: 異常なら鍵は出さない
note right: 改ざんを検出して起動阻止/鍵供給拒否

== マルウェアが鍵を狙う ==
Att -> OS: マルウェア侵入
OS -> TPM: ディスク鍵要求
alt OSが改ざん/異常
  TPM --> OS: 鍵を返さない
else 正常
  TPM --> OS: 鍵を返す（安全に復号）
end

== リモートアテステーション ==
Host -> RemoteServer: 証明要求
Host -> TPM: アテステーション用の署名取得
TPM --> Host: 署名（端末状態を証明）
Host -> RemoteServer: 署名送付（アクセス可否判定）
@enduml


@startuml
title TPM利用の違い：PC盗難シナリオ

actor "攻撃者" as Attacker
participant "TPM 2.0" as TPM
participant "Windows 11" as Win11
participant "Windows 10" as Win10
participant "Linux" as Linux

== Windows 11 (TPM 2.0必須) ==
Attacker -> Win11: PCを盗む
Win11 -> TPM: ディスク復号鍵を要求
TPM --> Win11: 状態を検証 (Secure Boot/Measured Boot)
alt 改ざんや不正起動
  Win11 <- TPM: 鍵を返さない
  Attacker -> Win11: データ読めない
else 正常起動
  TPM --> Win11: BitLocker鍵提供
  Win11 -> User: Windows Helloで認証
end

== Windows 10 (TPM任意) ==
Attacker -> Win10: PCを盗む
alt TPMなしPC
  Win10 -> Attacker: ディスク暗号化されていない
  Attacker -> Win10: データ読み取り可能
else TPMありPC
  Win10 -> TPM: BitLocker鍵要求
  TPM --> Win10: 鍵提供（オプション）
end

== Linux (TPM任意) ==
Attacker -> Linux: PCを盗む
alt TPM未設定
  Linux -> Attacker: LUKS鍵をユーザーが入力
  note right: パスワードが弱ければ突破可能
else TPM連携あり
  Linux -> TPM: LUKS鍵を要求
  TPM --> Linux: 状態検証後に鍵提供
end
@enduml


@startuml
title TPM利用の流れ比較（Linux vs Windows 11）

actor User

participant "TPM 2.0" as TPM
participant "Linux OS" as Linux
participant "Windows 11" as Win

== 起動 ==
User -> Linux: 電源ON
Linux -> TPM: (任意) 改ざんチェック(IMA)
note right: TPM利用はオプション

User -> Win: 電源ON
Win -> TPM: Secure Boot / Measured Boot
note right: TPM必須、改ざん検知を標準化

== ディスク暗号化 ==
Linux -> TPM: (任意) LUKSの鍵を保管
note right: ユーザーが設定すれば利用可能

Win -> TPM: BitLockerの鍵を格納
Win <- TPM: 改ざんなければ自動復号
note right: 標準機能で統合

== 認証 ==
Linux -> User: パスワード or 鍵ファイル
note right: TPM連携は追加設定が必要

Win -> TPM: Windows Helloの秘密鍵
Win -> User: PINや生体認証
Win <- TPM: 鍵で認証
note right: OS標準でTPMに依存

== OS利用中 ==
Linux -> TPM: (必要なら) tpm2-toolsで操作
note right: 開発者/管理者向けに限定

Win -> TPM: Credential Guard / Device Guard
note right: 資格情報をTPM連携で保護
@enduml
